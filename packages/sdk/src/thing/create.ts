import { execute } from "@mintbase-js/sdk";
import { AccountId, mint, MintArgs } from "@mintbase-js/sdk/lib/v1";
import type { FinalExecutionOutcome, Wallet } from '@near-wallet-selector/core';
import { isUuid, uuid } from 'uuidv4';
import { MINT_ARGS_NOT_PROVIDED, NOT_VALID_UUID, STORAGE_TYPE, USER_NOT_PROVIDED, WALLET_NOT_PROVIDED } from "../constants";
import { fetchEverything, GraphqlFetchingError } from "../utils";
import { createThingMutation } from "./create.mutation";

type CreateThingResults = {
  data: any | null,
  error: undefined | GraphqlFetchingError
}

type CreateThingResponse = {

}

export type CreateThingArgs = {
  storage: string[],
  user?: any, // this will come from Auth0, used to get access token
  characteristics?: Characteristic[],
  files?: File[],
  wallet?: any,
  ownerId?: AccountId,
  nftContractId?: AccountId
};

export type CreateThingCloudArgs = {
  user: any, // this will come from Auth0, used to get access token
  characteristics?: Characteristic[]
};

export type CreateThingBlockchainArgs = {
  wallet: any,
  ownerId: AccountId,
  nftContractId: AccountId
}

export async function createThing(args: CreateThingArgs) {
  const thingId = uuid();

  if (args.storage.includes(STORAGE_TYPE.CLOUD)) {
    // confirm user
    if (!args.user) {
      throw new Error(USER_NOT_PROVIDED);
    }
    const cloudArgs: CreateThingCloudArgs = {
      user: args.user,
      characteristics: args.characteristics
    }
    const { data: data, error } = await createThingOnCloud(thingId, cloudArgs);
  }

  if (args.storage.includes(STORAGE_TYPE.BLOCKCHAIN)) {
    // insert thingId into mintArgs
    if (!args.ownerId || !args.nftContractId) {
      throw new Error(MINT_ARGS_NOT_PROVIDED);
    }
    if (!args.wallet) {
      // throw error
      throw new Error(WALLET_NOT_PROVIDED);
    }
    const blockchainArgs: CreateThingBlockchainArgs = {
      wallet: args.wallet,
      ownerId: args.ownerId,
      nftContractId: args.nftContractId
    }
    const response = await createThingOnBlockchain(thingId, blockchainArgs)
  }
}

export async function createThingOnCloud(thingId: string, args: CreateThingCloudArgs): Promise<CreateThingResults> { // TODO: replace with own type
  if (!isUuid(thingId)) {
    throw new Error(NOT_VALID_UUID);
  }

  const variables = {
    input: {
      thingId: thingId,
      ownerId: args.user.sub,
      characteristics: args.characteristics,
    },
  };
  const { data, error } = await fetchEverything({ query: createThingMutation, variables });
  if (error) {
    console.error("Error creating thing", error.message);
    // Do anything?
  }
  return { data, error };
}

export async function createThingOnBlockchain(thingId: string, args: CreateThingBlockchainArgs): Promise<void | FinalExecutionOutcome> {
  if (!isUuid(thingId)) {
    // could verify that thingId exists in offline or cloud storage...
    throw new Error(NOT_VALID_UUID);
  }

  const mintArgs: MintArgs = {
    network: "testnet", // This will be env.property
    nftContractId: args.nftContractId, // This could be generated by the user
    metadata: {
      reference: "", // everything logo
    },
    options: {
      ownerId: args.ownerId,
      metadataId: thingId,
    },
  }

  // create reference on blockchain
  return execute(mint(mintArgs), { wallet: args.wallet });
}